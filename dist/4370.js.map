{"version":3,"file":"4370.js","mappings":"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","sources":["file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/cbor.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/commented.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/constants.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/decoder.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/diagnose.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/encoder.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/map.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/simple.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/tagged.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/lib/utils.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/cbor@8.1.0/node_modules/cbor/vendor/binary-parse-stream/index.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/nofilter@3.1.0/node_modules/nofilter/lib/index.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/shell-quote@1.7.3/node_modules/shell-quote/index.js"],"sourcesContent":["const flagSymbol = Symbol('arg flag');\n\nclass ArgError extends Error {\n\tconstructor(msg, code) {\n\t\tsuper(msg);\n\t\tthis.name = 'ArgError';\n\t\tthis.code = code;\n\n\t\tObject.setPrototypeOf(this, ArgError.prototype);\n\t}\n}\n\nfunction arg(\n\topts,\n\t{\n\t\targv = process.argv.slice(2),\n\t\tpermissive = false,\n\t\tstopAtPositional = false\n\t} = {}\n) {\n\tif (!opts) {\n\t\tthrow new ArgError(\n\t\t\t'argument specification object is required',\n\t\t\t'ARG_CONFIG_NO_SPEC'\n\t\t);\n\t}\n\n\tconst result = { _: [] };\n\n\tconst aliases = {};\n\tconst handlers = {};\n\n\tfor (const key of Object.keys(opts)) {\n\t\tif (!key) {\n\t\t\tthrow new ArgError(\n\t\t\t\t'argument key cannot be an empty string',\n\t\t\t\t'ARG_CONFIG_EMPTY_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (key[0] !== '-') {\n\t\t\tthrow new ArgError(\n\t\t\t\t`argument key must start with '-' but found: '${key}'`,\n\t\t\t\t'ARG_CONFIG_NONOPT_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new ArgError(\n\t\t\t\t`argument key must have a name; singular '-' keys are not allowed: ${key}`,\n\t\t\t\t'ARG_CONFIG_NONAME_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (typeof opts[key] === 'string') {\n\t\t\taliases[key] = opts[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet type = opts[key];\n\t\tlet isFlag = false;\n\n\t\tif (\n\t\t\tArray.isArray(type) &&\n\t\t\ttype.length === 1 &&\n\t\t\ttypeof type[0] === 'function'\n\t\t) {\n\t\t\tconst [fn] = type;\n\t\t\ttype = (value, name, prev = []) => {\n\t\t\t\tprev.push(fn(value, name, prev[prev.length - 1]));\n\t\t\t\treturn prev;\n\t\t\t};\n\t\t\tisFlag = fn === Boolean || fn[flagSymbol] === true;\n\t\t} else if (typeof type === 'function') {\n\t\t\tisFlag = type === Boolean || type[flagSymbol] === true;\n\t\t} else {\n\t\t\tthrow new ArgError(\n\t\t\t\t`type missing or not a function or valid array type: ${key}`,\n\t\t\t\t'ARG_CONFIG_VAD_TYPE'\n\t\t\t);\n\t\t}\n\n\t\tif (key[1] !== '-' && key.length > 2) {\n\t\t\tthrow new ArgError(\n\t\t\t\t`short argument keys (with a single hyphen) must have only one character: ${key}`,\n\t\t\t\t'ARG_CONFIG_SHORTOPT_TOOLONG'\n\t\t\t);\n\t\t}\n\n\t\thandlers[key] = [type, isFlag];\n\t}\n\n\tfor (let i = 0, len = argv.length; i < len; i++) {\n\t\tconst wholeArg = argv[i];\n\n\t\tif (stopAtPositional && result._.length > 0) {\n\t\t\tresult._ = result._.concat(argv.slice(i));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg === '--') {\n\t\t\tresult._ = result._.concat(argv.slice(i + 1));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg.length > 1 && wholeArg[0] === '-') {\n\t\t\t/* eslint-disable operator-linebreak */\n\t\t\tconst separatedArguments =\n\t\t\t\twholeArg[1] === '-' || wholeArg.length === 2\n\t\t\t\t\t? [wholeArg]\n\t\t\t\t\t: wholeArg\n\t\t\t\t\t\t\t.slice(1)\n\t\t\t\t\t\t\t.split('')\n\t\t\t\t\t\t\t.map((a) => `-${a}`);\n\t\t\t/* eslint-enable operator-linebreak */\n\n\t\t\tfor (let j = 0; j < separatedArguments.length; j++) {\n\t\t\t\tconst arg = separatedArguments[j];\n\t\t\t\tconst [originalArgName, argStr] =\n\t\t\t\t\targ[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n\n\t\t\t\tlet argName = originalArgName;\n\t\t\t\twhile (argName in aliases) {\n\t\t\t\t\targName = aliases[argName];\n\t\t\t\t}\n\n\t\t\t\tif (!(argName in handlers)) {\n\t\t\t\t\tif (permissive) {\n\t\t\t\t\t\tresult._.push(arg);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t\t`unknown or unexpected option: ${originalArgName}`,\n\t\t\t\t\t\t\t'ARG_UNKNOWN_OPTION'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst [type, isFlag] = handlers[argName];\n\n\t\t\t\tif (!isFlag && j + 1 < separatedArguments.length) {\n\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t`option requires argument (but was followed by another short argument): ${originalArgName}`,\n\t\t\t\t\t\t'ARG_MISSING_REQUIRED_SHORTARG'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (isFlag) {\n\t\t\t\t\tresult[argName] = type(true, argName, result[argName]);\n\t\t\t\t} else if (argStr === undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\targv.length < i + 2 ||\n\t\t\t\t\t\t(argv[i + 1].length > 1 &&\n\t\t\t\t\t\t\targv[i + 1][0] === '-' &&\n\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\targv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) &&\n\t\t\t\t\t\t\t\t(type === Number ||\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\t\t\t\t\t(typeof BigInt !== 'undefined' && type === BigInt))\n\t\t\t\t\t\t\t))\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst extended =\n\t\t\t\t\t\t\toriginalArgName === argName ? '' : ` (alias for ${argName})`;\n\t\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t\t`option requires argument: ${originalArgName}${extended}`,\n\t\t\t\t\t\t\t'ARG_MISSING_REQUIRED_LONGARG'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[argName] = type(argv[i + 1], argName, result[argName]);\n\t\t\t\t\t++i;\n\t\t\t\t} else {\n\t\t\t\t\tresult[argName] = type(argStr, argName, result[argName]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult._.push(wholeArg);\n\t\t}\n\t}\n\n\treturn result;\n}\n\narg.flag = (fn) => {\n\tfn[flagSymbol] = true;\n\treturn fn;\n};\n\n// Utility types\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\n\n// Expose error class\narg.ArgError = ArgError;\n\nmodule.exports = arg;\n","'use strict'\n\nexports.Commented = require('./commented')\nexports.Diagnose = require('./diagnose')\nexports.Decoder = require('./decoder')\nexports.Encoder = require('./encoder')\nexports.Simple = require('./simple')\nexports.Tagged = require('./tagged')\nexports.Map = require('./map')\n\n/**\n * Convenience name for {@linkcode Commented.comment}.\n */\nexports.comment = exports.Commented.comment\n\n/**\n * Convenience name for {@linkcode Decoder.decodeAll}.\n */\nexports.decodeAll = exports.Decoder.decodeAll\n\n/**\n * Convenience name for {@linkcode Decoder.decodeFirst}.\n */\nexports.decodeFirst = exports.Decoder.decodeFirst\n\n/**\n * Convenience name for {@linkcode Decoder.decodeAllSync}.\n */\nexports.decodeAllSync = exports.Decoder.decodeAllSync\n\n/**\n * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n */\nexports.decodeFirstSync = exports.Decoder.decodeFirstSync\n\n/**\n * Convenience name for {@linkcode Diagnose.diagnose}.\n */\nexports.diagnose = exports.Diagnose.diagnose\n\n/**\n * Convenience name for {@linkcode Encoder.encode}.\n */\nexports.encode = exports.Encoder.encode\n\n/**\n * Convenience name for {@linkcode Encoder.encodeCanonical}.\n */\nexports.encodeCanonical = exports.Encoder.encodeCanonical\n\n/**\n * Convenience name for {@linkcode Encoder.encodeOne}.\n */\nexports.encodeOne = exports.Encoder.encodeOne\n\n/**\n * Convenience name for {@linkcode Encoder.encodeAsync}.\n */\nexports.encodeAsync = exports.Encoder.encodeAsync\n\n/**\n * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n */\nexports.decode = exports.Decoder.decodeFirstSync\n\n/**\n * The codec information for\n * {@link https://github.com/Level/encoding-down encoding-down}, which is a\n * codec framework for leveldb.  CBOR is a particularly convenient format for\n * both keys and values, as it can deal with a lot of types that JSON can't\n * handle without losing type information.\n *\n * @example\n * const level = require('level')\n * const cbor = require('cbor')\n *\n * async function putget() {\n *   const db = level('./db', {\n *     keyEncoding: cbor.leveldb,\n *     valueEncoding: cbor.leveldb,\n *   })\n *\n *   await db.put({a: 1}, 9857298342094820394820394820398234092834n)\n *   const val = await db.get({a: 1})\n * }\n */\nexports.leveldb = {\n  decode: exports.Decoder.decodeFirstSync,\n  encode: exports.Encoder.encode,\n  buffer: true,\n  name: 'cbor',\n}\n\n/**\n * Reset everything that we can predict a plugin might have altered in good\n * faith.  For now that includes the default set of tags that decoding and\n * encoding will use.\n */\nexports.reset = function reset() {\n  exports.Encoder.reset()\n  exports.Tagged.reset()\n}\n","'use strict'\n\nconst stream = require('stream')\nconst utils = require('./utils')\nconst Decoder = require('./decoder')\nconst NoFilter = require('nofilter')\nconst {MT, NUMBYTES, SYMS} = require('./constants')\nconst {Buffer} = require('buffer')\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's'\n  }\n  return ''\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {commentCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'number':\n      return {options: {max_depth: opts}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.depth = depth\n    this.max_depth = max_depth\n    this.all = new NoFilter()\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this)\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('start-string', this._on_start_string.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this))\n    }\n    this.parser.bs.on('read', this._on_read.bind(this))\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({depth: this.depth + 1, no_summary: true})\n\n    c.on('data', b => this.push(b))\n    c.on('error', er => this.emit('error', er))\n    c.end(v)\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb)\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const bs = new NoFilter()\n    const {encoding = 'hex', ...opts} = options\n    const d = new Commented(opts)\n    let p = null\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'))\n      })\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'))\n        })\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ')\n    this.push(er.toString())\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf)\n    const hex = buf.toString('hex')\n\n    this.push(new Array(this.depth + 1).join('  '))\n    this.push(hex)\n\n    let ind = ((this.max_depth - this.depth) * 2) - hex.length\n    if (ind < 1) {\n      ind = 1\n    }\n    this.push(new Array(ind + 1).join(' '))\n    this.push('-- ')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,'\n        break\n      case MT.NEG_INT:\n        desc = 'Negative number,'\n        break\n      case MT.ARRAY:\n        desc = 'Array, length'\n        break\n      case MT.MAP:\n        desc = 'Map, count'\n        break\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length'\n        break\n      case MT.UTF8_STRING:\n        desc = 'String, length'\n        break\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,'\n        } else {\n          desc = 'Float,'\n        }\n        break\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`\n        break\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`\n        break\n    }\n    this.push(`${desc}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `)\n        break\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `)\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `)\n        }\n        break\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`)\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item')\n        }\n        break\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)')\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`)\n        }\n        break\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)')\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`)\n        }\n        break\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)')\n        break\n      case MT.UTF8_STRING:\n        this.push('String (streaming)')\n        break\n    }\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(mt) {\n    this.depth--\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `)\n          break\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `)\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `)\n          }\n          break\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity)\n\n    if ((typeof val === 'string') ||\n        (Buffer.isBuffer(val))) {\n      if (val.length > 0) {\n        this.push(str)\n        this.push('\\n')\n      }\n      this.depth--\n    } else {\n      this.push(str)\n      this.push('\\n')\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x')\n    this.push(this.all.read().toString('hex'))\n    this.push('\\n')\n  }\n}\n\nmodule.exports = Commented\n","'use strict'\n\n/**\n * @enum {number}\n */\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7,\n}\n\n/**\n * @enum {number}\n */\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36,\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  SET: 258,\n}\n\n/**\n * @enum {number}\n */\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31,\n}\n\n/**\n * @enum {number}\n */\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23,\n}\n\nexports.SYMS = {\n  NULL: Symbol.for('github.com/hildjj/node-cbor/null'),\n  UNDEFINED: Symbol.for('github.com/hildjj/node-cbor/undef'),\n  PARENT: Symbol.for('github.com/hildjj/node-cbor/parent'),\n  BREAK: Symbol.for('github.com/hildjj/node-cbor/break'),\n  STREAM: Symbol.for('github.com/hildjj/node-cbor/stream'),\n}\n\nexports.SHIFT32 = 0x100000000\n\nexports.BI = {\n  MINUS_ONE: BigInt(-1),\n  NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),\n  MAXINT32: BigInt('0xffffffff'),\n  MAXINT64: BigInt('0xffffffffffffffff'),\n  SHIFT32: BigInt(exports.SHIFT32),\n}\n\n","'use strict'\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst stream = require('stream')\nconst constants = require('./constants')\nconst {MT, NUMBYTES, SYMS, BI} = constants\nconst {Buffer} = require('buffer')\n\nconst COUNT = Symbol('count')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`)\n    this.name = 'UnexpectedDataError'\n    this.byte = byte\n    this.value = value\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {decodeCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options\n\n    super({defaultEncoding: encoding, ...superOpts})\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    this.preferWeb = preferWeb\n    this.extendedResults = extendedResults\n    this.required = required\n    this.preventDuplicateKeys = preventDuplicateKeys\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this))\n      this.valueBytes = /** @type {NoFilter} */ (new NoFilter())\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @static\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n\n    while (!state.done) {\n      const b = s.read(state.value)\n\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b)\n      }\n      state = parser.next(b)\n    }\n\n    let val = null\n    if (c.extendedResults) {\n      val = state.value\n      val.unused = s.read()\n    } else {\n      val = Decoder.nullcheck(state.value)\n      if (s.length > 0) {\n        const nextByte = s.read(1)\n\n        s.unshift(nextByte)\n        throw new UnexpectedDataError(nextByte[0], val)\n      }\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n    const res = []\n\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n\n      while (!state.done) {\n        const b = s.read(state.value)\n\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b)\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', required = false, ...opts} = options\n\n    const c = new Decoder(opts)\n    let v = /** @type {any} */ (NOT_FOUND)\n    const s = utils.guessEncoding(input, encoding)\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', er => {\n        if (c.extendedResults && (er instanceof UnexpectedDataError)) {\n          v.unused = c.bs.slice()\n          return resolve(v)\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            }\n            return resolve(v)\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb)\n    }\n    s.pipe(c)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const c = new Decoder(opts)\n    const vals = []\n\n    c.on('data', val => vals.push(Decoder.nullcheck(val)))\n\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined))\n    }\n    utils.guessEncoding(input, encoding).pipe(c)\n    return p\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data)\n  }\n\n  /**\n   * @yields {number} Number of bytes to read.\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`)\n      }\n\n      const [octet] = yield 1\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]))\n        throw new UnexpectedDataError(octet)\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent == null) ? undefined : parent[MAJOR]\n      const parent_length = (parent == null) ? undefined : parent.length\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          ;[val] = yield 1\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT: {\n          const numbytes = 1 << (ai - 24)\n\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ?\n            buf :\n            utils.parseCBORint(ai, buf)\n          break\n        }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error(`Additional info not implemented: ${ai}`)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX\n          } else {\n            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              if (mt === MT.UTF8_STRING) {\n                val = ''\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0)\n              }\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0)\n            )\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1\n        } else if (Array.isArray(parent)) {\n          parent.push(val)\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR]\n\n          if ((pm != null) && (pm !== mt)) {\n            this.running = false\n            throw new Error('Invalid major type in indefinite encoding')\n          }\n          parent.write(val)\n        }\n\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP: {\n              let allstrings = true\n\n              if ((parent.length % 2) !== 0) {\n                throw new Error(`Invalid map length: ${parent.length}`)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if ((typeof parent[i] !== 'string') ||\n                    (parent[i] === '__proto__')) {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys &&\n                    Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map()\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys && val.has(parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            }\n            case MT.TAG: {\n              const t = new Tagged(parent[0], parent[1])\n\n              val = t.convert(this.tags)\n              break\n            }\n          }\n        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {\n          // Only parent types are Array and NoFilter for (Array/Map) and\n          // (bytes/string) respectively.\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              if (this.preferWeb) {\n                val = new Uint8Array(\n                  /** @type {Buffer} */ (val).buffer,\n                  /** @type {Buffer} */ (val).byteOffset,\n                  /** @type {Buffer} */ (val).length\n                )\n              }\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice()\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length,\n          }\n\n          this.valueBytes = new NoFilter()\n          return ret\n        }\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n","'use strict'\n\nconst stream = require('stream')\nconst Decoder = require('./decoder')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst {MT, SYMS} = require('./constants')\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      }\n      return cb(er)\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @throws {TypeError} Input not provided.\n   * @returns {Promise} If callback not specified.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString())\n    } else {\n      this.emit('error', er)\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3,\n      }[len]\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ')\n          } else {\n            this.push(', ')\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    const fb = this.float_bytes\n    this.float_bytes = -1\n    this.push(utils.cborValueToString(val, fb))\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ')\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')')\n        break\n      case MT.ARRAY:\n        this.push(']')\n        break\n      case MT.MAP:\n        this.push('}')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')')\n        break\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n","'use strict'\n\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst {\n  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,\n} = constants\nconst {Buffer} = require('buffer')\n\nconst HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO\nconst FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR\nconst DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT\nconst TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE\nconst FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE\nconst UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED\nconst NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL\n\nconst BREAK = Buffer.from([0xff])\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {}\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {}\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number'\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number'\n    case 'float':\n      return 'float'\n    case 'int':\n    case 'integer':\n      return 'int'\n    case 'string':\n      return 'string'\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`)\n}\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true,\n    })\n\n    this.canonical = canonical\n    this.encodeUndefined = encodeUndefined\n    this.disallowUndefinedKeys = disallowUndefinedKeys\n    this.dateType = parseDateType(dateType)\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet()\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet')\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties\n\n    this.semanticTypes = {...Encoder.SEMANTIC_TYPES}\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1])\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v)\n      }\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    return cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    return cb()\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *    how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *    but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *    Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *    If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *    then we'll encode this as a float rather than making the number\n   *    negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n    let max = Number.MAX_SAFE_INTEGER\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *    but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    }\n    return this._pushInt(obj, MT.POS_INT)\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN()\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj)\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj))\n      case 'object': {\n        const buf = utils.bufferishToBuffer(this.encodeUndefined)\n        if (buf) {\n          return this.push(buf)\n        }\n      }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  /**\n   * @param {null} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32))\n    }\n\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts,\n    }\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`)\n        } else {\n          this.detectLoops.add(obj)\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR\n      if (typeof f === 'function') {\n        return f.call(obj, this)\n      }\n      const converter = this.semanticTypes[obj.constructor.name]\n      if (converter) {\n        return converter.call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k]\n      return (tv !== 'function') &&\n        (!this.omitUndefinedProperties || (tv !== 'undefined'))\n    })\n    const cbor_keys = {}\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck = null\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // Already a Buffer\n          return false\n        }\n      } else if (!this._pushString(k)) {\n        return false\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj)\n    }\n    return true\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark})\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = (typeof type === 'string') ? type : type.name\n    const old = this.semanticTypes[typeName]\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function')\n      }\n      this.semanticTypes[typeName] = fun\n    } else if (old) {\n      delete this.semanticTypes[typeName]\n    }\n    return old\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`)\n        }\n      default:\n        throw new TypeError(\n          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`\n        )\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    const len = obj.length\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false\n    }\n    this.detectLoops = new WeakSet()\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj.getTime() / 1000))\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj.getTime() / 1000)\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj.getTime() / 1000)\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()))\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    let entries = [...obj.entries()]\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([k, v]) => v !== undefined)\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers,\n      })\n      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000\n    let sz = obj.BYTES_PER_ELEMENT\n    const {name} = obj.constructor\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000\n      sz /= 2\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000\n    }\n    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {\n      typ |= 0b00000100\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11,\n    }[sz]\n    if (!gen._pushTag(typ)) {\n      return false\n    }\n    return Encoder._pushBuffer(\n      gen,\n      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n    )\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode')\n      }\n      obj = this\n    }\n\n    // TODO: consider other options\n    const {chunkSize = 4096} = options\n\n    let ret = true\n    const objType = typeof obj\n    let buf = null\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && gen._pushString(obj.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if ((buf = utils.bufferishToBuffer(obj))) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true,\n      })\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true,\n      })\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding')\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true,\n      })\n    }\n    return ret\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true,\n    })._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES}\n  }\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer, // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter, // Mßight be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed,\n})\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray\n}\n\nEncoder.reset()\nmodule.exports = Encoder\n","'use strict'\n\nconst {Buffer} = require('buffer')\nconst encoder = require('./encoder')\nconst decoder = require('./decoder')\nconst {MT} = require('./constants')\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @extends Map\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   *\n   * @param {Iterable<any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable)\n  }\n\n  /**\n   * @ignore\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64')\n  }\n\n  /**\n   * @ignore\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64')\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key))\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store.\n   * @returns {this} This object.\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val)\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete. Can be any\n   *   type, which will be serialized into CBOR and compared by value.\n   * @returns {boolean} True if an element in the Map object existed and has\n   *   been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key))\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean} True if an element with the specified key exists in\n   *   the Map object; otherwise false.\n   */\n  has(key) {\n    return super.has(CborMap._encode(key))\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @yields {any} The keys of the map.\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k)\n    }\n  }\n\n  /* eslint-disable jsdoc/require-returns-check */\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @yields {any[]} Key value pairs.\n   * @returns {IterableIterator<any, any>} Key value pairs.\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]]\n    }\n  }\n  /* eslint-enable jsdoc/require-returns-check */\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator} Key value pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *  each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback.\n   * @throws {TypeError} Invalid function.\n   */\n  forEach(fun, thisArg) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function')\n    }\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this)\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]])\n      entries.sort((a, b) => a[0].compare(b[0]))\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nmodule.exports = CborMap\n","'use strict'\n\nconst {MT, SIMPLE, SYMS} = require('./constants')\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`)\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error(`value must be a small positive integer: ${value}`)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} depth How deep are we?\n   * @param {object} opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, opts) {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null\n        }\n        return SYMS.NULL\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined\n        }\n        return SYMS.UNDEFINED\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n","'use strict'\n\nconst constants = require('./constants')\nconst utils = require('./utils')\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON')\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn)\n    }\n  } else if (obj && (typeof obj === 'object')) {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn)\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this)\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this)\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex')\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab)\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64],\n  }[size]\n\n  const end = byteOffset + byteLength\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true))\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis\n    } else {\n      setBuffersToJSON(v, b64urlThis)\n    }\n    return tag\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this\n    } else {\n      setBuffersToJSON(v, b64this)\n    }\n    return tag\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis\n    } else {\n      setBuffersToJSON(v, hexThis)\n    }\n    return tag\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters')\n    }\n    const last = v.length % 4\n    if (last === 1) {\n      throw new Error('Invalid base64url length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/)\n    if (!m) {\n      throw new Error('Invalid base64 characters')\n    }\n    if ((v.length % 4) !== 0) {\n      throw new Error('Invalid base64 length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v),\n}\n\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array,\n  // 87: not implemented, float128 array\n}\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array\n  TYPED_ARRAY_TAGS[71] = BigUint64Array\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array\n  TYPED_ARRAY_TAGS[79] = BigInt64Array\n}\n\nfunction _toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer')\n  }\n  const {tag} = tagged\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag]\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`)\n  }\n  const little = tag & 0b00000100\n  const float = (tag & 0b00010000) >> 4\n  const sz = 2 ** (float + (tag & 0b00000011))\n\n  if ((!little !== utils.isBigEndian()) && (sz > 1)) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength)\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength)\n  return new TypedClass(ab)\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = _toTypedArray\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {}\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`)\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`)\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value)\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value,\n    }\n    if (this.err) {\n      ret.err = this.err\n    }\n    return ret\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = (converters == null) ? undefined : converters[this.tag]\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(this, this.value, this)\n    } catch (error) {\n      if (error && error.message && (error.message.length > 0)) {\n        this.err = error.message\n      } else {\n        this.err = error\n      }\n      return this\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {...TAGS}\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON\nTagged.reset()\nmodule.exports = Tagged\n","'use strict'\n\nconst {Buffer} = require('buffer')\nconst NoFilter = require('nofilter')\nconst stream = require('stream')\nconst constants = require('./constants')\nconst {NUMBYTES, SHIFT32, BI, SYMS} = constants\nconst MAX_SAFE_HIGH = 0x1fffff\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n *\n * @private\n */\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\nexports.utf8 = buf => td.decode(buf)\nexports.utf8.checksUTF8 = true\n\nfunction isReadable(s) {\n  // Is this a readable stream?  In the webpack version, instanceof isn't\n  // working correctly.\n  if (s instanceof stream.Readable) {\n    return true\n  }\n  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function')\n}\n\nexports.isBufferish = function isBufferish(b) {\n  return b &&\n    (typeof b === 'object') &&\n    ((Buffer.isBuffer(b)) ||\n      (b instanceof Uint8Array) ||\n      (b instanceof Uint8ClampedArray) ||\n      (b instanceof ArrayBuffer) ||\n      (b instanceof DataView))\n}\n\nexports.bufferishToBuffer = function bufferishToBuffer(b) {\n  if (Buffer.isBuffer(b)) {\n    return b\n  } else if (ArrayBuffer.isView(b)) {\n    return Buffer.from(b.buffer, b.byteOffset, b.byteLength)\n  } else if (b instanceof ArrayBuffer) {\n    return Buffer.from(b)\n  }\n  return null\n}\n\nexports.parseCBORint = function parseCBORint(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0)\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0)\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0)\n    case NUMBYTES.EIGHT: {\n      const f = buf.readUInt32BE(0)\n      const g = buf.readUInt32BE(4)\n      if (f > MAX_SAFE_HIGH) {\n        return (BigInt(f) * BI.SHIFT32) + BigInt(g)\n      }\n      return (f * SHIFT32) + g\n    }\n    default:\n      throw new Error(`Invalid additional info for int: ${ai}`)\n  }\n}\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  // Sign, exponent, mantissa\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000 // Top bit is sign\n  const exp = (u >> 23) & 0xff // Then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  // Hildjj: zeros already handled.  Assert if you don't believe me.\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n  } else if ((exp >= 103) && (exp < 113)) {\n    // Denormalized numbers\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false\n  }\n\n  // Done\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16)\n  return true\n}\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1\n  const exp = (buf[0] & 0x7C) >> 2\n  const mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? NaN : Infinity)\n  }\n  return sign * (2 ** (exp - 25)) * (1024 + mant)\n}\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf)\n    case 4:\n      return buf.readFloatBE(0)\n    case 8:\n      return buf.readDoubleBE(0)\n    default:\n      throw new Error(`Invalid float size: ${buf.length}`)\n  }\n}\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex')\n}\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '')\n  let start = 0\n  let end = (s.length % 8) || 8\n  const chunks = []\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2))\n    start = end\n    end += 8\n  }\n  return Buffer.from(chunks)\n}\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i])\n}\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt(`0x${buf.toString('hex')}`)\n}\n\nexports.cborValueToString = function cborValueToString(val, float_bytes = -1) {\n  switch (typeof val) {\n    case 'symbol': {\n      switch (val) {\n        case SYMS.NULL:\n          return 'null'\n        case SYMS.UNDEFINED:\n          return 'undefined'\n        case SYMS.BREAK:\n          return 'BREAK'\n      }\n      // Impossible in node 10\n      /* istanbul ignore if */\n      if (val.description) {\n        return val.description\n      }\n      // On node10, Symbol doesn't have description.  Parse it out of the\n      // toString value, which looks like `Symbol(foo)`.\n      const s = val.toString()\n      const m = s.match(/^Symbol\\((?<name>.*)\\)/)\n      /* istanbul ignore if */\n      if (m && m.groups.name) {\n        // Impossible in node 12+\n        /* istanbul ignore next */\n        return m.groups.name\n      }\n      return 'Symbol'\n    }\n    case 'string':\n      return JSON.stringify(val)\n    case 'bigint':\n      return val.toString()\n    case 'number': {\n      const s = Object.is(val, -0) ? '-0' : String(val)\n      return (float_bytes > 0) ? `${s}_${float_bytes}` : s\n    }\n    case 'object': {\n      // A null should be caught above\n      const buf = exports.bufferishToBuffer(val)\n      if (buf) {\n        const hex = buf.toString('hex')\n        return (float_bytes === -Infinity) ? hex : `h'${hex}'`\n      }\n      if (typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {\n        return val[Symbol.for('nodejs.util.inspect.custom')]()\n      }\n      // Shouldn't get non-empty arrays here\n      if (Array.isArray(val)) {\n        return '[]'\n      }\n      // This should be all that is left\n      return '{}'\n    }\n  }\n  return String(val)\n}\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input === 'string') {\n    return new NoFilter(input, (encoding == null) ? 'hex' : encoding)\n  }\n  const buf = exports.bufferishToBuffer(input)\n  if (buf) {\n    return new NoFilter(buf)\n  }\n  if (isReadable(input)) {\n    return input\n  }\n  throw new Error('Unknown input type')\n}\n\nconst B64URL_SWAPS = {\n  '=': '',\n  '+': '-',\n  '/': '_',\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64url string.\n * @private\n */\nexports.base64url = function base64url(buf) {\n  return exports.bufferishToBuffer(buf)\n    .toString('base64')\n    .replace(/[=+/]/g, c => B64URL_SWAPS[c])\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64 string.\n * @private\n */\nexports.base64 = function base64(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64')\n}\n\nexports.isBigEndian = function isBigEndian() {\n  const array = new Uint8Array(4)\n  const view = new Uint32Array(array.buffer)\n  return !((view[0] = 1) & array[0])\n}\n","// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict'\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @param {stream.TransformOptions} options Stream options.\n   * @memberof BinaryParseStream\n   */\n  constructor(options) {\n    super(options)\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true\n\n    this.bs = new NoFilter()\n    this.__restart()\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh)\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null\n      const chunk = (this.__needed === null) ?\n        undefined :\n        this.bs.read(this.__needed)\n\n      try {\n        ret = this.__parser.next(chunk)\n      } catch (e) {\n        return cb(e)\n      }\n\n      if (this.__needed) {\n        this.__fresh = false\n      }\n\n      if (ret.done) {\n        this.push(ret.value)\n        this.__restart()\n      } else {\n        this.__needed = ret.value || Infinity\n      }\n    }\n\n    return cb()\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, undefined, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() { // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass')\n  }\n\n  __restart() {\n    this.__needed = null\n    this.__parser = this._parse()\n    this.__fresh = true\n  }\n\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'))\n  }\n}\n\nmodule.exports = BinaryParseStream\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict'\n\nconst stream = require('stream')\nconst {Buffer} = require('buffer')\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\n\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding, options = {}) {\n    let inp = null\n    let inpE = /** @type {BufferEncoding?} */ (null)\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n        } else if (input) {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid input')\n    }\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding\n        }\n        break\n      case 'string':\n        inpE = /** @type {BufferEncoding} */ (inputEncoding)\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid inputEncoding')\n    }\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options')\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe\n    delete options.watchPipe\n    const readError = Boolean(options.readError)\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode\n        // @ts-ignore: TS2339 (using internal interface)\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream'\n          )\n        }\n\n        // @ts-ignore: TS2339 (using internal interface)\n        this._readableState.objectMode = om\n        // @ts-ignore: TS2339 (using internal interface)\n        this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    }\n    return nf1.compare(nf2)\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @ignore\n   */\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n  readFull(size) {\n    let onReadable = null\n    let onFinish = null\n    let onError = null\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size))\n        return\n      }\n\n      // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n        return\n      }\n\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size))\n        }\n      }\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n      }\n      onError = reject\n      this.on('readable', onReadable)\n      this.on('error', onError)\n      this.on('finish', onFinish)\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable)\n        this.removeListener('error', onError)\n        this.removeListener('finish', onFinish)\n      }\n    })\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', er => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    }\n\n    const buf1 = this.slice()\n    const buf2 = other.slice()\n    // These will both be buffers because of the check above.\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2)\n    }\n    throw new Error('Cannot compare streams in object mode')\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default: {\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n      }\n    }\n  }\n\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    }\n    return b\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if (!encoding || (encoding === 'utf8')) {\n      return td.decode(buf)\n    }\n    return buf.toString(encoding)\n  }\n\n  /**\n   * @ignore\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string')\n      }\n      return JSON.stringify(b)\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt(`0x${b.toString('hex')}`)\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt(`0x${b.toString('hex')}`)\n    // Negative?\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret -= mask\n    }\n    return ret\n  }\n\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n  writeUInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n  writeInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt8()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16BE()\n  }\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32BE()\n  }\n\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt8()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16BE()\n  }\n\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32BE()\n  }\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatLE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatLE()\n  }\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatBE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatBE()\n  }\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleLE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleLE()\n  }\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleBE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleBE()\n  }\n\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64LE()\n  }\n\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64BE()\n  }\n\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64LE()\n  }\n\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64BE()\n  }\n}\n\nmodule.exports = NoFilter\n","exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n"],"names":["flagSymbol","Symbol","ArgError","Error","constructor","msg","code","super","this","name","Object","setPrototypeOf","prototype","arg","opts","argv","process","slice","permissive","stopAtPositional","result","_","aliases","handlers","key","keys","length","type","isFlag","Array","isArray","fn","value","prev","push","Boolean","i","len","wholeArg","concat","separatedArguments","split","map","a","j","originalArgName","argStr","undefined","argName","match","Number","BigInt","flag","COUNT","v","existingCount","module","exports","Commented","Diagnose","Decoder","Encoder","Simple","Tagged","Map","comment","decodeAll","decodeFirst","decodeAllSync","decodeFirstSync","diagnose","encode","encodeCanonical","encodeOne","encodeAsync","decode","leveldb","buffer","reset","stream","utils","NoFilter","MT","NUMBYTES","SYMS","Buffer","plural","c","Transform","options","depth","max_depth","no_summary","tags","preferWeb","encoding","superOpts","readableObjectMode","writableObjectMode","all","_tag_24","bind","parser","on","_on_value","_on_start","_on_start_string","_on_stop","_on_more","_on_error","_on_data","bs","_on_read","b","er","emit","end","_transform","fresh","cb","write","_flush","static","input","TypeError","normalizeOptions","d","p","toString","Promise","resolve","reject","pipe","guessEncoding","buf","hex","join","ind","mt","parent_mt","pos","desc","POS_INT","NEG_INT","ARRAY","MAP","BYTE_STRING","UTF8_STRING","SIMPLE_FLOAT","tag","Math","floor","TAG","STREAM","val","ai","BREAK","str","cborValueToString","isBuffer","ONE","TWO","FOUR","EIGHT","read","DATE_STRING","DATE_EPOCH","POS_BIGINT","NEG_BIGINT","DECIMAL_FRAC","BIGFLOAT","BASE64URL_EXPECTED","BASE64_EXPECTED","BASE16_EXPECTED","CBOR","URI","BASE64URL","BASE64","REGEXP","MIME","SET","ZERO","INDEFINITE","SIMPLE","FALSE","TRUE","NULL","UNDEFINED","for","PARENT","SHIFT32","BI","MINUS_ONE","NEG_MAX","MAX_SAFE_INTEGER","MAXINT32","MAXINT64","BinaryParseStream","constants","MAJOR","ERROR","NOT_FOUND","parentArray","parent","typ","count","parentBufferStream","UnexpectedDataError","byte","required","extendedResults","preventDuplicateKeys","defaultEncoding","running","_onRead","valueBytes","s","_parse","state","next","done","unused","nullcheck","nextByte","unshift","res","close","once","then","vals","__fresh","data","octet","from","parent_major","parent_length","numbytes","parseCBORint","Uint8Array","allocUnsafe","utf8","byteOffset","hasParent","parseCBORfloat","again","pm","allstrings","hasOwnProperty","call","has","set","convert","old","bytes","ret","separator","stream_errors","float_bytes","_fore","fb","HALF","FLOAT","DOUBLE","BUF_NAN","BUF_INF_NEG","BUF_INF_POS","BUF_NEG_ZERO","SEMANTIC_TYPES","current_SEMANTIC_TYPES","canonical","encodeUndefined","disallowUndefinedKeys","dateType","collapseBigIntegers","detectLoops","omitUndefinedProperties","genTypes","toLowerCase","parseDateType","WeakSet","semanticTypes","addSemanticType","k","entries","pushAny","_pushUInt8","writeUInt8","_pushUInt16BE","writeUInt16BE","_pushUInt32BE","writeUInt32BE","_pushFloatBE","writeFloatBE","_pushDoubleBE","writeDoubleBE","_pushNaN","_pushInfinity","obj","half","_pushFloat","b2","writeHalf","fround","_pushInt","orig","m","max","_pushIntNum","is","_pushNumber","isNaN","isFinite","round","_pushString","byteLength","_pushBoolean","_pushUndefined","bufferishToBuffer","_pushNull","_pushTag","_pushJSBigint","_pushBuffer","_pushObject","indefinite","skipTypes","add","f","encodeCBOR","converter","filter","tv","cbor_keys","sort","a_cbor","b_cbor","compare","ck","len2","delete","_encodeAll","objs","highWaterMark","readableHighWaterMark","o","fun","typeName","gen","removeLoopDetectors","toISOString","getTime","source","size","x","valueOf","enc","sz","BYTES_PER_ELEMENT","startsWith","includes","isBigEndian","chunkSize","objType","offset","endIndex","pushArray","_pushMap","bufs","assign","Date","_pushDate","_pushNoFilter","RegExp","_pushRegexp","Set","_pushSet","ArrayBuffer","_pushArrayBuffer","Uint8ClampedArray","_pushTypedArray","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","URL","_pushURL","_pushBoxed","String","BigUint64Array","BigInt64Array","encoder","decoder","CborMap","iterable","get","_encode","_decode","kv","iterator","forEach","thisArg","has_parent","parent_indefinite","INTERNAL_JSON","setBuffersToJSON","isBufferish","toJSON","values","b64this","base64","b64urlThis","base64url","hexThis","TAGS","bufferToBigInt","last","indexOf","groups","padding","TYPED_ARRAY_TAGS","_toTypedArray","tagged","TypedClass","ab","dv","DataView","getter","setter","getUint16","setUint16","getUint32","setUint32","getBigUint64","setBigUint64","swapEndian","n","current_TAGS","err","JSON","stringify","converters","error","message","td","TextDecoder","fatal","ignoreBOM","checksUTF8","isView","readUInt8","readUInt16BE","readUInt32BE","g","u32","u","s16","exp","mant","parseHalf","sign","NaN","Infinity","readFloatBE","readDoubleBE","replace","bin","start","chunks","parseInt","arrayEqual","every","elem","description","Readable","B64URL_SWAPS","array","objectMode","__restart","__needed","chunk","__parser","e","create","ctor","superCtor","super_","enumerable","writable","configurable","TempCtor","inputEncoding","inp","inpE","watchPipe","readError","readable","om","_readableState","_writableState","nf1","nf2","list","alloc","reduce","tot","nf","allBufs","allObjs","callback","_bufArray","head","readFull","onReadable","onFinish","onError","writableFinished","finally","removeListener","promise","other","buf1","buf2","equals","index","stylize","writeBigInt","readUBigInt","readBigInt","writeUInt16LE","writeUInt32LE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeDoubleLE","writeBigInt64LE","writeBigInt64BE","writeBigUInt64LE","writeBigUInt64BE","readUInt16LE","readUInt32LE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readDoubleLE","readBigInt64LE","readBigInt64BE","readBigUInt64LE","readBigUInt64BE","CONTROL","TOKEN","pow","random","env","mapped","chunker","commented","test","op","BS","escape","quote","esc","out","isGlob","charAt","parseEnvVar","pattern","varend","varname","pre","r","substr","parse","acc","xs"],"sourceRoot":""}